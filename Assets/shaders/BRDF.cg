
#define PI 3.14159265f


// Physically based shading model
// parameterized with the below options

// Microfacet specular = D*G*F / (4*NoL*NoV) = D*Vis*F
// Vis = G / (4*NoL*NoV)

// Diffuse model
// 0: Lambert
// 1: Burley
// 2: Oren-Nayar
#define PHYSICAL_DIFFUSE	0

// Microfacet distribution function
// 0: Blinn
// 1: Beckmann
// 2: GGX
#define PHYSICAL_SPEC_D		2

// Geometric attenuation or shadowing
// 0: Implicit
// 1: Neumann
// 2: Kelemen
// 3: Schlick
// 4: Smith (matched to GGX)
#define PHYSICAL_SPEC_G		5

float rcp(float x)
{
	return 1.f / x;
}

// Fresnel
// 0: None
// 1: Schlick
// 2: Fresnel
#define PHYSICAL_SPEC_F		2

float Pow5( float x )
{
	float x2 = x*x;
	return x2 * x2 * x;
}

float Square(float x)
{
	return x * x;
}

float3 Diffuse_Lambert( float3 DiffuseColor )
{
	return DiffuseColor * (1 / PI);
}

// [Burley 2012, "Physically-Based Shading at Disney"]
float3 Diffuse_Burley( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float FD90 = 0.5 + 2 * VoH * VoH * Roughness;
	float FdV = 1 + (FD90 - 1) * Pow5( 1 - NoV );
	float FdL = 1 + (FD90 - 1) * Pow5( 1 - NoL );
	return DiffuseColor * ( (1 / PI) * FdV * FdL );
}

// [Gotanda 2012, "Beyond a Simple Physically Based Blinn-Phong Model in Real-Time"]
float3 Diffuse_OrenNayar( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float a = Roughness * Roughness;
	float s = a;// / ( 1.29 + 0.5 * a );
	float s2 = s * s;
	float VoL = 2 * VoH * VoH - 1;		// double angle identity
	float Cosri = VoL - NoV * NoL;
	float C1 = 1 - 0.5 * s2 / (s2 + 0.33);
	float C2 = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0 ? rcp( max( NoL, NoV ) ) : 1 );
	return DiffuseColor / PI * ( C1 + C2 ) * ( 1 + Roughness * 0.5 );
}

// [Gotanda 2014, "Designing Reflectance Models for New Consoles"]
float3 Diffuse_Gotanda( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float F0 = 0.04;
	float VoL = 2 * VoH * VoH - 1;		// double angle identity
	float Cosri = VoL - NoV * NoL;
#if 1
	float a2_13 = a2 + 1.36053;
	float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - NoV, 1 + rcp(39*a2*a2+1) ) + 1 );
	//float Fr = ( 1 - 0.36 * a ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( -2.5 * Roughness * ( 1 - NoV ) + 1 );
	float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - Pow5( 1 - NoL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a * (NoL - 1) ) * NoL;
	float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * NoV) ) ) * ( 1 - pow( 1 - NoL, ( 1 - 0.3726732 * NoV * NoV ) / ( 0.188566 + 0.38841 * NoV ) ) );
	float Bp = Cosri < 0 ? 1.4 * NoV * NoL * Cosri : Cosri;
	float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
	return DiffuseColor / PI * Lr;
#else
	float a2_13 = a2 + 1.36053;
	float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - NoV, 1 + rcp(39*a2*a2+1) ) + 1 );
	float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - Pow5( 1 - NoL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a + 0.5*a * NoL );
	float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * NoV) ) ) * ( 1 - pow( 1 - NoL, ( 1 - 0.3726732 * NoV * NoV ) / ( 0.188566 + 0.38841 * NoV ) ) );
	float Bp = Cosri < 0 ? 1.4 * NoV * Cosri : Cosri / max( NoL, 1e-8 );
	float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
	return DiffuseColor / PI * Lr;
#endif
}

// [Blinn 1977, "Models of light reflection for computer synthesized pictures"]
float D_Blinn( float Roughness, float NoH )
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float n = 2 / a2 - 2;
	return (n+2) / (2*PI) * PhongShadingPow( NoH, n );		// 1 mad, 1 exp, 1 mul, 1 log
}

// [Beckmann 1963, "The scattering of electromagnetic waves from rough surfaces"]
float D_Beckmann( float Roughness, float NoH )
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float NoH2 = NoH * NoH;
	return exp( (NoH2 - 1) / (a2 * NoH2) ) / ( PI * a2 * NoH2 * NoH2 );
}

// GGX / Trowbridge-Reitz
// [Walter et al. 2007, "Microfacet models for refraction through rough surfaces"]
float D_GGX( float Roughness, float NoH )
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float d = ( NoH * a2 - NoH ) * NoH + 1;	// 2 mad
	return a2 / ( PI*d*d );	// 4 mul, 1 rcp
}

// Anisotropic GGX
// [Burley 2012, "Physically-Based Shading at Disney"]
float D_GGXaniso( float RoughnessX, float RoughnessY, float NoH, float3 H, float3 X, float3 Y )
{
	float ax = RoughnessX * RoughnessX;
	float ay = RoughnessY * RoughnessY;
	float XoH = dot( X, H );
	float YoH = dot( Y, H );
	float d = XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay) + NoH*NoH;
	return 1 / ( PI * ax*ay * d*d );
}

float Vis_Implicit()
{
	return 1;
}

// [Neumann et al. 1999, "Compact metallic reflectance models"]
float Vis_Neumann( float NoV, float NoL )
{
	return 1 / ( 4 * max( NoL, NoV ) );
}

// [Kelemen 2001, "A microfacet based coupled specular-matte brdf model with importance sampling"]
float Vis_Kelemen( float VoH )
{
	return rcp( 4 * VoH * VoH );
}

// Tuned to match behavior of Vis_Smith
// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
float Vis_Schlick( float Roughness, float NoV, float NoL )
{
	float k = Square( Roughness ) * 0.5;
	float Vis_SchlickV = NoV * (1 - k) + k;
	float Vis_SchlickL = NoL * (1 - k) + k;
	return 0.25 / ( Vis_SchlickV * Vis_SchlickL );
}

float Vis_Schlick_C( float Roughness, float NoV, float NoL )
{
	float k = Square( Roughness ) * 0.5;
	float Vis_SchlickV = NoV * (1 - k) + k;
	float Vis_SchlickL = NoL * (1 - k) + k;
	return NoL * NoV * rcp( Vis_SchlickV * Vis_SchlickL );
}

// Smith term for GGX
// [Smith 1967, "Geometrical shadowing of a random rough surface"]
float Vis_Smith( float Roughness, float NoV, float NoL )
{
	float a = Square( Roughness );
	float a2 = a*a;

	float Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
	float Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
	return rcp( Vis_SmithV * Vis_SmithL );
}

// Smith term for GGX
// [Smith 1967, "Geometrical shadowing of a random rough surface"]
float Vis_Smith_C( float Roughness, float NoV, float NoL )
{
	float a = Square( Roughness );
	float a2 = a*a;

	float Vis_SmithV = NoV + saturate(sqrt( NoV * (NoV - NoV * a2) + a2));
	float Vis_SmithL = NoL + saturate(sqrt( NoL * (NoL - NoL * a2) + a2));
	float val = NoL * NoV * rcp( 0.25 * Vis_SmithV * Vis_SmithL );
	return saturate(val);
}

// Appoximation of joint Smith term for GGX
// [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
float Vis_SmithJointApprox( float Roughness, float NoV, float NoL )
{
	float a = Square( Roughness );
	float Vis_SmithV = NoL * ( NoV * ( 1 - a ) + a );
	float Vis_SmithL = NoV * ( NoL * ( 1 - a ) + a );
	return 0.5 * rcp( Vis_SmithV + Vis_SmithL );
}

// Appoximation of joint Smith term for GGX
// [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
float Vis_SmithJointApprox_C( float Roughness, float NoV, float NoL )
{
	float a = Square( Roughness );
	float Vis_SmithV = NoL * ( NoV * ( 1 - a ) + a );
	float Vis_SmithL = NoV * ( NoL * ( 1 - a ) + a );
	return 2 * NoV * NoL * rcp( Vis_SmithV + Vis_SmithL );
}

float3 F_None( float3 SpecularColor )
{
	return SpecularColor;
}

// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
float3 F_Schlick( float3 SpecularColor, float VoH )
{
	float Fc = Pow5( 1 - VoH );					// 1 sub, 3 mul
	//return Fc + (1 - Fc) * SpecularColor;		// 1 add, 3 mad
	
	// Anything less than 2% is physically impossible and is instead considered to be shadowing
	return saturate( 50.0 * SpecularColor.g ) * Fc + (1 - Fc) * SpecularColor;
	
}

float3 F_Fresnel( float3 SpecularColor, float VoH )
{
	float3 SpecularColorSqrt = sqrt( clamp( float3(0, 0, 0), float3(0.99, 0.99, 0.99), SpecularColor ) );
	float3 n = ( 1 + SpecularColorSqrt ) / ( 1 - SpecularColorSqrt );
	float3 g = sqrt( n*n + VoH*VoH - 1 );
	return 0.5 * Square( (g - VoH) / (g + VoH) ) * ( 1 + Square( ((g+VoH)*VoH - 1) / ((g-VoH)*VoH + 1) ) );
}


float3 Diffuse( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
#if   PHYSICAL_DIFFUSE == 0
	return Diffuse_Lambert( DiffuseColor );
#elif PHYSICAL_DIFFUSE == 1
	return Diffuse_Burley( DiffuseColor, Roughness, NoV, NoL, VoH );
#elif PHYSICAL_DIFFUSE == 2
	return Diffuse_OrenNayar( DiffuseColor, Roughness, NoV, NoL, VoH );
#endif
}

float Distribution( float Roughness, float NoH )
{
#if   PHYSICAL_SPEC_D == 0
	return D_Blinn( Roughness, NoH );
#elif PHYSICAL_SPEC_D == 1
	return D_Beckmann( Roughness, NoH );
#elif PHYSICAL_SPEC_D == 2
	return D_GGX( Roughness, NoH );
#endif
}

// Vis = G / (4*NoL*NoV)
float GeometricVisibility( float Roughness, float NoV, float NoL, float VoH )
{
#if   PHYSICAL_SPEC_G == 0
	return Vis_Implicit();
#elif PHYSICAL_SPEC_G == 1
	return Vis_Neumann( NoV, NoL );
#elif PHYSICAL_SPEC_G == 2
	return Vis_Kelemen( VoH );
#elif PHYSICAL_SPEC_G == 3
	return Vis_Schlick( Roughness, NoV, NoL );
#elif PHYSICAL_SPEC_G == 4
	return Vis_Smith( Roughness, NoV, NoL );
#elif PHYSICAL_SPEC_G == 5
	return Vis_SmithJointApprox( Roughness, NoV, NoL );
#endif
}

float3 Fresnel( float3 SpecularColor, float VoH )
{
#if   PHYSICAL_SPEC_F == 0
	return F_None( SpecularColor );
#elif PHYSICAL_SPEC_F == 1
	return F_Schlick( SpecularColor, VoH );
#elif PHYSICAL_SPEC_F == 2
	return F_Fresnel( SpecularColor, VoH );
#endif
}

float D_InvBlinn( float Roughness, float NoH )
{
	float m = Roughness * Roughness;
	float m2 = m * m;
	float A = 4;
	float Cos2h = NoH * NoH;
	float Sin2h = 1 - Cos2h;
	//return rcp( PI * (1 + A*m2) ) * ( 1 + A * ClampedPow( Sin2h, 1 / m2 - 1 ) );
	return rcp( PI * (1 + A*m2) ) * ( 1 + A * exp( -Cos2h / m2 ) );
}

float D_InvBeckmann( float Roughness, float NoH )
{
	float m = Roughness * Roughness;
	float m2 = m * m;
	float A = 4;
	float Cos2h = NoH * NoH;
	float Sin2h = 1 - Cos2h;
	float Sin4h = Sin2h * Sin2h;
	return rcp( PI * (1 + A*m2) * Sin4h ) * ( Sin4h + A * exp( -Cos2h / (m2 * Sin2h) ) );
}

float Vis_Cloth( float NoV, float NoL )
{
	return rcp( 4 * ( NoL + NoV - NoL * NoV ) );
}





float pow2(float x)
{
return x*x;
}

float pow3(float x)
{
return x*x*x;
}

float pow4(float x)
{
return x*x*x*x;
}

float Diffuse_Nemeth(float Roughness, float SpecularColor, float NoL)
{
	float minDiffuseEnergy = (19483*pow4(Roughness))/10000 + (3223*pow3(Roughness)*SpecularColor)/4000 + 
	(34117*pow3(Roughness)*NoL)/50000 - (47187*pow3(Roughness))/10000 + 
	(30527*pow2(Roughness)*pow2(SpecularColor))/50000 + (10399*pow2(Roughness)*SpecularColor*NoL)/20000 -
	(20303*pow2(Roughness)*SpecularColor)/10000 - (12077*pow2(Roughness)*pow2(NoL))/50000 -
	(5573*pow2(Roughness)*NoL)/5000 + (19277*pow2(Roughness))/5000 +
	(1059*Roughness*pow3(SpecularColor))/6250 - (3756650*Roughness*pow2(SpecularColor)*NoL)/144115188 -
	(46697*Roughness*pow2(SpecularColor))/50000 - (4143*Roughness*SpecularColor*pow2(NoL))/25000 -
	(1078*Roughness*SpecularColor*NoL)/3125 + (11967*Roughness*SpecularColor)/10000 -
	(979*Roughness*pow3(NoL))/20000 + (43833*Roughness*pow2(NoL))/100000 +
	(4577*Roughness*NoL)/12500 - (3629*Roughness)/4000 +
	(310850*pow4(SpecularColor))/230584300 - (431*pow3(SpecularColor)*NoL)/2500 -
	(184280*pow3(SpecularColor))/14411518 - (15561*pow2(SpecularColor)*pow2(NoL))/100000 +
	(6841*pow2(SpecularColor)*NoL)/12500 + (873438*pow2(SpecularColor))/14411518 -
	(2913202*SpecularColor*pow3(NoL))/576460752 + (7301*SpecularColor*pow2(NoL))/20000 -
	(2653*SpecularColor*NoL)/5000 - (11001*SpecularColor)/100000 +
	(8261*pow4(NoL))/50000 - (24503*pow3(NoL))/100000 -
	(5813*pow2(NoL))/50000 + (14777*NoL)/100000 + 1288.f/15625;

	return minDiffuseEnergy / 3.1415f * 2.f;
}

float3 F_Schlick (float3 f0 , float f90 , float u )
{
	return f0 + ( f90 - f0 ) * pow (1.f - u , 5.f);
}

float3 Fr_DisneyDiffuse ( float NdotV , float NdotL , float LdotH , float linearRoughness, float3 SpecularF0 )
{
 float energyBias = lerp (0 , 0.5 , linearRoughness );
 float energyFactor = 1.0;//lerp (1.0 , 1.0 / 1.51 , linearRoughness );
 float fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness ;
 float3 lightScatter = F_Schlick ( SpecularF0 , fd90 , NdotL ) .r;
 float3 viewScatter = F_Schlick (SpecularF0 , fd90 , NdotV ).r;
  
 return lightScatter * viewScatter * energyFactor / 3.14159265f;
}

float3 Diffuse_Nemeth(float NdotL, float Roughness, float3 SpecularColor)
{
	return (1 - SpecularColor) * 1.0 / ( 3.14159265358979 * NdotL ) * ((pow(NdotL, 0.4)*(SpecularColor - 1)*(- 6*pow(Roughness,6) + 7*pow(Roughness,5.0) + 21*Roughness - 42))/42 - (Roughness*NdotL*(SpecularColor - (pow(Roughness,5.0)*(SpecularColor - 1))/6)*(Roughness*NdotL - 6))/8);
}